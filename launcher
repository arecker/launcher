#!/usr/bin/env python
import argparse
import collections
import configparser
import logging
import os
import pathlib
import re
import subprocess
import sys

logging.basicConfig(stream=sys.stderr,
                    level=logging.INFO,
                    format='launcher: %(message)s')
logger = logging.getLogger(__name__)

parser = argparse.ArgumentParser()

parser.add_argument('--verbose',
                    default=False,
                    action='store_true',
                    help='print debug logs')

parser.add_argument('--config', required=True, help='path to config file')

config = configparser.ConfigParser()

Job = collections.namedtuple('Job', 'key directory command env')


def parse_path(value, base=None):
    if value.startswith('../') or value.startswith('./'):
        return (base / value).absolute()
    return pathlib.Path(os.path.expanduser(value)).absolute()


def configured_jobs(base_dir):
    for section in config.sections():
        kwargs = {}
        info = config[section]
        kwargs['command'] = os.path.expandvars(info['command']).split(' ')
        kwargs['directory'] = parse_path(info['directory'], base=base_dir)

        if 'envfile' in info.keys():
            envfile_pattern = re.compile(
                r'^(?P<key>.*?)=[\'\"]?(?P<value>.*?)[\'\"]?$')
            envfile_target = parse_path(value=info['envfile'], base=base_dir)
            with open(envfile_target) as f:
                kwargs['env'] = dict(envfile_pattern.findall(f.read()))
                logger.debug('loaded %d key(s) from %s',
                             len(kwargs['env'].keys()), envfile_target)

        yield Job(key=section, **kwargs)


def main():
    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    logger.debug('called with args = %s', vars(args))

    config.read(args.config)
    logger.debug('loaded config from %s', args.config)

    base_dir = pathlib.Path(args.config).parent

    children = []
    for job in configured_jobs(base_dir=base_dir):
        process = subprocess.Popen(job.command,
                                   cwd=job.directory,
                                   env=job.env,
                                   encoding='UTF-8',
                                   text=True,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        children.append(process)
        logger.info('launched child %d for job %s', process.pid, job)

    logger.info('waiting for jobs to be complete...')
    try:
        for child in children:
            child.wait()
            logger.info('process %s stopped, returning %d', child.pid,
                        child.returncode)
            logger.debug('\n--- stdout\n%s\n--- stderr\n%s\n---',
                         child.stdout.read(), child.stderr.read())
    except (InterruptedError, KeyboardInterrupt):
        logger.info('parent process interrupted')
    finally:
        for child in children:
            child.kill()
            logger.debug('killed process %s (pid %d)', child, child.pid)


if __name__ == '__main__':
    main()
